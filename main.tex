\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}

\title{Functional ntuple filters for ROOT}
\author{Jim Pivarski}
% \institute{Where You're From}
% \date{Date of Presentation}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[fragile]{Motivation}

\begin{block}{}
The process of cutting and transforming ntuples, putting results in plots, is the essence of exploratory data analysis. It's the primary way physicists interact with data and learn things from it.
\end{block}

\begin{block}{}
ROOT has a mini-language for cuts and transformations:
{\scriptsize \begin{verbatim}
    ttree->Draw("fNtrack / fNvertex", "fIsValid && fFlag == 1")
\end{verbatim}}
Like an SQL-select and SQL-where (no SQL-groupby).
\end{block}

\begin{itemize}
\item Good for quick plots (very important!)
\item Some transformations cannot be expressed (good and bad, depending)
\item Users can go beyond this by writing explicit for-loops over ntuple contents, but at a cost:
\begin{itemize}
\item Explicit, imperative programs can't be easily parallelized
\item Pointer issues and reusing data (for speed) can lead to subtle bugs with stale data
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivation}
C++11 introduced a syntax for inline functions, which would make a functional style convenient. For instance, the mini-language could be replaced by:
{\scriptsize \begin{verbatim}
    [](Event _) { return _.fNtrack / _.fNvertex; }
    [](Event _) { return _.fIsValid && _.fFlag == 1; }
\end{verbatim}}

Functional pipelines form the basis of data manipulation in R, NumPy, Hadoop, Spark, SQL, Lisp, and others.

The basic style is (Spark example):
{\scriptsize \begin{verbatim}
    val output = input.filter(x => x.fIsValid && x.fFlag == 1)
                      .map(x => x.fNtrack / x.fNvertex)    // set up chain
    output.take(10)                                        // get 10 outputs
\end{verbatim}}
\begin{itemize}
\item No explicit index, only dummy variables
\item Small collection of functors that accept inline functions
\item Parallelization is handled by back-end code
\end{itemize}
\end{frame}

\end{document}
