\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}

\title{Functional ntuple filters for ROOT}
\author{Jim Pivarski}
% \institute{Where You're From}
% \date{Date of Presentation}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[fragile]{Motivation}

\begin{block}{}
The process of cutting and transforming ntuples, putting results in plots, is the essence of exploratory data analysis. It's the primary way physicists interact with data and learn things from it.
\end{block}

\begin{block}{}
ROOT has a mini-language for cuts and transformations:
{\scriptsize \begin{verbatim}
    ttree->Draw("fNtrack / fNvertex", "fIsValid && fFlag == 1")
\end{verbatim}}
Like an SQL-select and SQL-where (no SQL-groupby).
\end{block}

\begin{itemize}
\item Good for quick plots (very important!)
\item Some transformations cannot be expressed (good and bad, depending)
\item Users can go beyond this by writing explicit for-loops over ntuple contents, but at a cost:
\begin{itemize}
\item Explicit, imperative programs can't be easily parallelized
\item Pointer issues and reusing data (for speed) can lead to major bugs from uninitialized data and subtle bugs from stale data
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivation}
C++11 introduced a syntax for inline functions, which would make a functional style convenient. For instance, the mini-language could be replaced by:
{\scriptsize \begin{verbatim}
    ntuple->Draw([](Event _) { return _.fNtrack / _.fNvertex; },
                 [](Event _) { return _.fIsValid && _.fFlag == 1; });
\end{verbatim}}

\vfill
Functional pipelines form the basis of data manipulation in R, NumPy, Hadoop, Spark, SQL, Lisp, and others.

\vfill
The basic style is (Spark example):
{\scriptsize \begin{verbatim}
    val output = input.filter(x => x.fIsValid && x.fFlag == 1)
                      .map(x => x.fNtrack / x.fNvertex)    // set up chain
    output.take(10)                                        // get 10 outputs
\end{verbatim}}
\begin{itemize}
\item No explicit index, only dummy variables
\item Small collection of functors that accept inline functions
\item Parallelization is handled by back-end code
\item Data source may have unknown or infinite size
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exploratory examples}

\begin{itemize}
\item Looked at {\tt dt\_DrawTest.C}, {\tt dt\_MakeRef.C}, and {\tt stress.cxx} for examples.
\item Set up a test in Python:
\begin{itemize}
\item Implemented some common functors with a fluent style: {\tt collection.functor(userFunction)...}
\item Converted {\tt Event.root} from ROOT testing suite into Avro for Pythonic access.
\item Using PyROOT to verify that ROOT syntax and functional chains produce identical histograms.
\end{itemize}
\end{itemize}

{\scriptsize \begin{verbatim}
ttree.Draw("fNtrack >> hNtrack")
assert Data.source().map(lambda _: _.fNtrack).verify("hNtrack")
\end{verbatim}}
\end{frame}

\end{document}
